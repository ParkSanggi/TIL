# arcus
   1. 필요성
      1. 일반적인 관계형 데이터베이스가 처리할 수 있는 요청의 수는 제한적이다.
      2. 어플리케이션과 데이터베이스에 캐시를 두어 hot data를 저장하면 요청시 disk에 접근하는 시간을 줄일 수 있어서 처리시간을 줄일 수 있다.

   2. 흐름
      1. 요청이 들어온 경우
         1. 어플리케이션이 요청에 필요한 정보를 찾기위해 database에 접근하기 전에 arcus의 캐시 클라우드 안에 원하는 정보가 들어있는지 확인한다.
            1. 요청이 들어오면 admin_address(zookeeper의 ip port)와 service_code(client_name)를 받아서 클라이언트 객체 생성
            2. service_code를 가지고 zookeeper client를 이용해서 디렉터리 구조에 있는 캐시 리스트를 가져온다.
            3. locator.connector가 캐시 노드들에 대한 해시 링을 구성하고 요청에 필요한 캐시를 검색.
               1. consistent hash를 사용하여 노드가 죽거나 추가되어도 모든 키를 재배치하지 않아도 되게 구성.
         1. 캐시 노드들 안에서 정보를 찾을 수 없는 경우에 database에 접근해서 정보를 찾고 캐시에 저장한다.

      1. 데이터를 업데이트 하는 경우
         1. database를 업데이트하고 캐시를 삭제해줘야 한다.

   3. memcached에서 확장된 기능
      1. value를 단일 값 뿐만 아니라 value의 collection을 구조화된 형태로 패키징해서 저장할 수 있다.(list, set, b+tree)

## consistent hash
    1. Key의 집합을 K, 슬롯의 크기를 N라고 했을 때, N의 갯수가 바뀌더라도 대부분의 키들이 슬롯을 그대로 사용할 수 있는 해싱 기법.
    2. 슬롯이 추가되거나 삭제됐을 때, K/n만큼만 조정된다.
    3. Consistent는 모든 경우에 consistent가 아닌, 가능한 consistent를 유지한다는 의미이다.

## 캐시
   1. 지역성의 원리에 기반한다.
      1. 최근에 요청받은 데이터는 다시 요청받을 확률이 높다.
   2. 매우 짧은 시간 동안 유지되는 메모리와 같다.
   3. 용량이 매우 제한적이지만 데이터 저장소보다 매우 빠르다.
   
   4. 전역 캐시(global cache)
      1. 모든 노드가 오직 하나의 캐시 공간만을 사용한다.
      2. 서버나 파일 저장소를 추가하더라도 잘 동작한다.
      3. 원래의 저장소보다 빠르고, 모든 요청 레이어 노드에서 접근이 가능하다.
      4. 클라이언트의 개수나 요청 개수가 급격하게 증가하면 하나의 캐시가 그 요청을 감당하지 못할 수도 있기 때문에 복잡해질 수 있다.
      5. 특화된 하드웨어를 사용해서 전역캐시를 빠르게 만들 수 있거나, 캐시가 필요한 데이터의 양이 고정된 일정량일 때 매우 유용하다.
      6. 전역 캐시의 일반적인 구현
         1. 요청 받은 데이터를 캐시에서 찾을 수 없을 경우
            1. 캐시 자신이 스토리지에 질의
               1. 전역캐시를 사용하는 대부분의 애플리케이션은 같은 요청이 여러 요청 노드로부터 발생하는 것을 막기 위해 캐시 스스로가 데이터 축출과 조회를 직접하는
            2. 요청 노드가 스토리지에 질의

## 파티션
   1. 수직적 확장
      1. 개개의 서버에 더 많은 자원을 추가하는 것을 말한다.
         1. 많은 데이터를 처리하기 위해 서버에 하드 디스크를 추가하는 것이 이에 해당한다.
         2. 더 빠른 계산 성능을 위해 더 빠른 CPU나 큰 용량의 메모리를 추가하는 것 역시 마찬가지다.
         3. 즉 수직적 확장은 각 자원의 처리 능력을 향상시키는 것을 말한다.

   2. 수평적 확장
      1. 노드를 추가하는 것을 말한다.
         1. 데이터가 많을 경우에는 부분 데이터를 저장할 수 있는 노드를 추가하는 것이다.
         2. 많은 연산을 필요로 하는 경우에는 연산을 분리하여 추가한 노드에서 작업이 이루어지도록 한다

      2. 수평적 확장을 하는 가장 보편적인 방법은 서비스를 파티션이나 샤드 단위로 분할하는 것이다
		https://d2.naver.com/helloworld/206816


## shared nothing
   1. shared disk
      1. 복수의 서버가 1대의 디스크를 사용하는 구성을 'Shared Disk'라고 한다.
      2. Shared Disk 타입의 Active-Active 구성은 DB 서버를 늘려도 무한으로 처리율이 향상되지 않는다.
      3. 이것은 저장소가 공유 자원이라서 쉽게 늘리기 어렵고 DB 서버 대수가 증가할수록 'DB 서버 간의 정보공유를 위한 오버헤드'가 크기 때문이다.
   2. shared nothing
      1. hared Nothing은 문자 그대로 '아무것도 공유하지 않는다'란 의미로 네트워크 이외의 자원을 모두 분리하는 방식이다.
      2. 이 아키텍처는 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상되는 장점이 있다.
      3. 장점
         1. 비용 대비 성능이 좋다.
         2. 같은 구성의 DB서버를 횡으로 나열하기 때문에 구조가 간단하며 원칙적으로 DB서버 수에 비례해서 저장소가 늘어난다.
      4. 단점
         1. 저장소를 공유하지 않는다. 즉, 각각의 DB 서버가 동일한 1개의 데이터에 접근할 수 없다.
            1.  DB 서버 하나가 다운되었을 때 다른 DB서버가 이를 이어받아 계속 처리할 수 있게 하는 '커버링(Covering)' 구성 등의 방법을 고려해야 한다.
		https://milhouse93.tistory.com/43

## 샤드
   1. 샤딩(sharding)
      1. 하나의 거대한 데이터베이스나 네트워크 시스템을 여러 개의 작은 조각으로 나누어 분산 저장하여 관리하는 것을 말한다.
      2. 단일의 데이터베이스에서 저장하기 너무 클 때 사용하여 데이터를 구간별로 쪼개어 나눔으로써 노드에 무겁게 가지고 있던 데이터를 빠르게 검증할 수 있어 빠른 트랜잭션 속도를 향상시킬 수 있다.
         1. 트랜잭션(transaction)이란 "더이상 쪼갤 수 없는 업무 처리의 최소 단위"를 말한다. 거래내역이라고도 한다.
         2. 트랜잭션 처리가 정상적으로 완료된 경우 커밋(commit)을 하고, 오류가 발생할 경우 원래 상태대로 롤백(rollback)을 한다.
         3. http://wiki.hash.kr/index.php/트랜잭션
   2. 샤딩을 통해 나누어진 블록들의 구간(epoch)을 샤드(shard)라고 부른다.


## 분산 시스템(distributed system)
    1. 하나의 시스템 처럼 보이는 독립된 컴퓨터들의 집합
        (A distributed system is a collection of independent computers that appears to its users as a sigle coherent system)
    2. 네트워크 상의 여러 요소들을 하나의 시스템처럼 활용하게 할 수 있는 시스템
    3. 분산 시스템의 컴포넌트들은 자율적이다. 
    4. 서비스를 받는 사용자는 분산 시스템을 하나의 시스템으로 생각한다.
    5. 디자인 원칙
        1. 다양한 컴퓨터(or 장비)들 사이에 다양한 통신 방법들을 어떻게 사용자로 부터 숨길 것인가?
        2. 어떻게 사용자와 시스템 간의 일관적이고 단일화된 커뮤니케이션 통로만들 것인가?
    1. 분산시스템이 필요한 이유
        1. 자원의 부족.
            1. 컴퓨터의 CPU 파워, 메모리, 하드 디스크 스토리지 등등 우리가 사용하는 모든 컴퓨터의 자원을 의미
        2. 장애시 대처
            1. 여러 대의 머신이 분산하여 연산을 처리하고 데이터를 저장하고 있다면 한대의 장애가 전체 시스템의 장애로 이어지지는 않는다.
        3. 접근의 편의성
            1. 목적 달성을 위해 다양한 자원들이 필요한 사용자에게 일관적이고 단일화된 방식으로 사용자가 원하는 자원에 쉽게 접근하게 할 수 있다.
            1. 예를 들어서 특정 인터넷 페이지가 있다고 가정해 보자. 우리는 이 페이지를 저장하고 있는 서버가 어디에 있으며 아이피가 무엇인지 알지 못한다.
                하지만 인터넷 브라우저에 url을 입력하면 우리가 원하는 사이트에 접속하고, 우리가 원하는 정보를 얻을 수 있다.
                여기서 url은 단일화된 자원 접근 방법이고, 사용자는 이 자원이 실제 세계 어떤 서버에 있는지에 대한 고민은 전혀 하지 않아도 된다.
        4. 투명성
            - Access : 데이터 표현 방식, 자원에 접근 방법을 사용자에게 숨긴다.
            - Location : 자원이 어디에 위치하고 있는지 사용자에게 숨긴다.
            - Migration : 자원의 이동을 사용자에게 숨긴다(이동하더라도 동일한 방법으로 접근 할 수 있음을 의미한다)
            - Relocation : 사용자가 사용 중임에도 자원이 이동 할 수 있다. 하지만 이 사실을 사용자에게 숨긴다.
            - Replication : 자원은 복사 될 수 있다. 하지만 사용자는 자기가 복사본에 접근하는지, 원본에 접근하는지 모른다.
            - Concurrency : 접근 자원이 다른 사용자와 함께 공유되고 있어도 사용자는 모른다.
            - Persistance : 자원이 메모리에 있든, 하드디스크에 있든 사용자는 모른다.
                출처: https://kukuta.tistory.com/156 [HardCore in Programming]